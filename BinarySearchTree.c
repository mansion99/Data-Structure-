#include<stdio.h>
#include<stdlib.h>
typedefenum{false,true}boolean;
structnode
{
intdata;
structnode*llink;
structnode*rlink;
};
typedefstructnode*treeptr;
voidinsert(treeptr*root,intd)
{
if((*root)==NULL)
{
*root=(treeptr)malloc(sizeof(structnode));
(*root)->data=d;
(*root)->llink=NULL;

(*root)->rlink=NULL;
return;
}
elseif(d>((*root)->data))
{
insert(&((*root)->rlink),d);
}
elseif(d<((*root)->data))
{
insert(&((*root)->llink),d);
}
}
booleansearch(treeptrroot,intd)
{
if(root==NULL)
returnfalse;
elseif(root->data==d)
{
returntrue;
}
elseif(d>((root)->data))
{
returnsearch((root)->rlink,d);
}
elseif(d<((root)->data))
{
returnsearch(((root)->llink),d);
}
}
voidinOrder(treeptrptr)
{
if(ptr)
{
inOrder(ptr->llink);
printf("%d\t",ptr->data);
inOrder(ptr->rlink);
}
}
treeptrqueue[10];
intfront,rear;
voidaddq(treeptrptr)
{
queue[rear++]=ptr;
}
treeptrdeleteq()
{
if(front!=rear)
returnqueue[front++];
returnNULL;
}

intmain()
{
treeptrroot;
root=NULL;
intchoice,data;
while(1)
{
printf("1.Insert\n2.InOrderTraversal\n3.Search");
scanf("%d",&choice);
switch(choice)
{
case1:
printf("Enterdatatobeinserted");
scanf("%d",&data);
insert(&root,data);
break;
case2:
inOrder(root);
printf("\n");
break;
case3:
printf("Enterdatatobesearchedfor:");
scanf("%d",&data);
if(search(root,data))
printf("Datafound\n");
else
printf("Datanotfound\n");
break;
default:printf("InvalidEntry\n");
break;
}
}
}
